# NanoClaw 분석 문서

## 1. 프로젝트 요약

`nanoclaw`는 "작고 이해 가능한 개인용 에이전트 시스템"을 목표로 한다.  
핵심 전략은 단순하다.

- 단일 Node.js 프로세스로 오케스트레이션 유지
- 에이전트 실행은 반드시 컨테이너 격리
- 그룹 단위 세션/메모리/큐 분리

---

## 2. 핵심 설계 철학

문서와 코드에서 일관되게 보이는 방향은 다음과 같다.

1. 기능 확장보다 코드 이해 가능성을 우선
2. 앱 레벨 권한체계보다 OS 레벨 격리(컨테이너) 우선
3. 범용 플랫폼보다 1인 사용자 최적화
4. 설정 파일 확장보다 코드 수정 중심 커스터마이징

---

## 3. 아키텍처 구성

## 3.1 전체 구조

호스트 프로세스가 WhatsApp/DB/스케줄러/큐를 관리하고, 실제 에이전트 실행은 컨테이너로 오프로드한다.

- 채널: WhatsApp(Baileys)
- 저장소: SQLite
- 실행: Apple Container(또는 Docker 변형)
- 통신: 파일 기반 IPC

## 3.2 오케스트레이터

- `src/index.ts`가 상태 로딩, 메시지 폴링, 그룹 라우팅, 에이전트 호출을 담당한다.
- 그룹별 커서(`last_agent_timestamp`)를 관리해 중복 처리/롤백을 제어한다.
- 스트리밍 결과를 즉시 사용자에게 전달하되, 에러 시 커서 롤백 여부를 조건부로 처리한다.

## 3.3 그룹 큐/동시성 제어

- `src/group-queue.ts`는 그룹별 상태와 전역 동시 실행 제한(`MAX_CONCURRENT_CONTAINERS`)을 함께 관리한다.
- 메시지와 스케줄 태스크를 같은 큐 정책으로 다루며, task 우선 처리 규칙이 있다.
- 실패 시 지수 백오프 재시도, 최대 재시도 상한을 둔다.

## 3.4 컨테이너 런너

- `src/container-runner.ts`는 그룹별 마운트 세트를 동적으로 구성한다.
- 메인 그룹과 일반 그룹의 권한/마운트 범위를 다르게 둔다.
- 그룹별 `.claude` 세션, 그룹별 IPC namespace, 스킬 동기화를 내장한다.
- 출력 마커(`OUTPUT_START/END`) 기반 스트리밍 파싱으로 실시간 응답 전송을 구현한다.

## 3.5 스케줄러

- `src/task-scheduler.ts`는 due task를 조회해 그룹 큐에 enqueue한다.
- 태스크 실행도 일반 메시지와 동일하게 컨테이너 에이전트 실행 경로를 사용한다.
- 실행 결과/오류/다음 실행 시각을 DB에 기록한다.

## 3.6 라우터

- `src/router.ts`는 최소 기능(메시지 XML 포맷, internal 태그 제거, outbound 라우팅)만 제공한다.
- 룰 엔진을 키우지 않고 단순 포맷터로 남긴 점이 설계 의도와 일치한다.

---

## 4. 보안 모델 요약

`docs/SECURITY.md` 기준 보안 경계는 명확하다.

1. 1차 경계: 컨테이너 격리
2. 2차 경계: 마운트 allowlist + 차단 패턴
3. 3차 경계: 그룹별 세션/IPC 분리
4. 4차 경계: main/non-main 권한 차등
5. 5차 경계: 컨테이너 전달 환경변수 화이트리스트

특히 mount allowlist를 프로젝트 외부 경로에 두고, 컨테이너에 마운트하지 않는 점이 중요하다.

---

## 5. 멀티에이전트 관점 핵심 인사이트

- "멀티에이전트"를 복잡한 계층 플래너가 아니라 "그룹별 독립 실행 컨텍스트"로 모델링한다.
- 그룹별 세션/파일시스템/IPC 분리로 교차 오염을 줄인다.
- Agent Swarm 지원을 하되, 기본 구조는 단순 오케스트레이터를 유지한다.
- 실시간 채팅 처리와 스케줄 처리 경로를 최대한 통합해 유지보수성을 확보한다.

---

## 6. 장점

- 작은 코드베이스 대비 실제 운영 기능(채널/스케줄/격리)이 충분하다.
- 격리 경계가 코드/문서 양쪽에서 명시적이다.
- 장애 시 재시도, 커서 롤백, 로그 기록 등 운영 안정성 장치가 있다.
- 기능 추가보다 변형(fork + skill) 전략이 분명하다.

---

## 7. 리스크 및 한계

- 단일 채널 중심(WhatsApp)이라 범용 제품화에는 추가 설계가 필요하다.
- 네트워크 접근이 비교적 넓게 허용되어, 고위험 환경에서는 추가 정책이 필요하다.
- 컨테이너 내 인증정보 노출 가능성(문서에 명시된 trade-off)이 남아 있다.
- 단순성을 유지하는 대신 대규모 운영 기능(정교한 관측/분산 큐)은 제한적이다.

---

## 8. rust-claw 적용 포인트

도입 가치가 높은 순서로 정리하면 아래와 같다.

1. 그룹 단위 실행 컨텍스트 분리  
세션/작업 디렉터리/IPC를 그룹 또는 에이전트 단위로 분리한다.

2. 큐/스케줄 실행 경로 통합  
채팅 실행과 예약 작업 실행을 동일 런타임 경로로 처리한다.

3. 마운트 보안 정책 외부화  
allowlist를 프로젝트 외부에 두고 컨테이너에서 수정 불가하게 유지한다.

4. 커서 롤백 정책 채택  
스트리밍 일부 전송 후 실패 시 "중복 전송 방지"를 고려한 롤백 규칙을 명시한다.

---

## 9. 분석 근거 파일

- `reference/nanoclaw/README.md`
- `reference/nanoclaw/docs/SPEC.md`
- `reference/nanoclaw/docs/REQUIREMENTS.md`
- `reference/nanoclaw/docs/SECURITY.md`
- `reference/nanoclaw/src/index.ts`
- `reference/nanoclaw/src/group-queue.ts`
- `reference/nanoclaw/src/container-runner.ts`
- `reference/nanoclaw/src/task-scheduler.ts`
- `reference/nanoclaw/src/router.ts`
